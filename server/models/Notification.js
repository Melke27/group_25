const mongoose = require('mongoose');

const notificationSchema = new mongoose.Schema({
  // Core notification data
  title: {
    type: String,
    required: true,
    maxlength: [200, 'Title cannot exceed 200 characters']
  },
  message: {
    type: String,
    required: true,
    maxlength: [1000, 'Message cannot exceed 1000 characters']
  },
  type: {
    type: String,
    required: true,
    enum: [
      'system',           // System maintenance, updates
      'security',         // Security alerts, login attempts
      'approval',         // Approvals needed
      'workflow',         // Status changes
      'deadline',         // Upcoming deadlines
      'milestone',        // Achievements, targets reached
      'error',           // Error notifications
      'warning',         // Warning messages
      'info',            // Informational messages
      'success',         // Success confirmations
      'reminder',        // Reminders and follow-ups
      'communication',   // Messages, comments
      'analytics',       // Reports, insights
      'content',         // New content available
      'event',           // Events, exhibitions
      'rental',          // Rental requests, updates
      'user_activity',   // User registration, activity
      'backup',          // Backup status
      'maintenance'      // Scheduled maintenance
    ]
  },
  category: {
    type: String,
    required: true,
    enum: [
      'artifact_management',
      'user_management',
      'system_administration',
      'content_approval',
      'financial',
      'security',
      'technical',
      'business_operations',
      'communication',
      'analytics',
      'compliance',
      'maintenance'
    ]
  },
  priority: {
    type: String,
    required: true,
    enum: ['low', 'medium', 'high', 'critical', 'urgent'],
    default: 'medium'
  },
  
  // Recipients and targeting
  recipients: [{
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true
    },
    readAt: Date,
    dismissedAt: Date,
    actionTaken: Date,
    response: String
  }],
  
  // Targeting rules
  targetingRules: {
    roles: [{
      type: String,
      enum: ['super_admin', 'admin', 'museum_admin', 'staff', 'visitor', 'educator', 'tour_admin']
    }],
    museums: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Museum' }],
    departments: [String],
    userGroups: [String],
    conditions: [{
      field: String,
      operator: { type: String, enum: ['equals', 'contains', 'greater_than', 'less_than', 'in'] },
      value: mongoose.Schema.Types.Mixed
    }]
  },

  // Action and interaction
  action: {
    type: { 
      type: String, 
      enum: ['none', 'redirect', 'api_call', 'download', 'approve', 'review', 'acknowledge'],
      default: 'none'
    },
    url: String,
    method: String,
    data: mongoose.Schema.Types.Mixed,
    buttonText: String,
    confirmationRequired: { type: Boolean, default: false },
    confirmationMessage: String
  },
  
  // Scheduling and delivery
  delivery: {
    immediate: { type: Boolean, default: true },
    scheduled: Date,
    channels: [{
      type: { type: String, enum: ['in_app', 'email', 'sms', 'push', 'webhook'] },
      enabled: { type: Boolean, default: true },
      settings: mongoose.Schema.Types.Mixed
    }],
    frequency: {
      type: String,
      enum: ['once', 'daily', 'weekly', 'monthly', 'on_condition'],
      default: 'once'
    },
    repeatUntil: Date,
    maxDeliveries: Number,
    deliveryCount: { type: Number, default: 0 }
  },

  // Smart features
  smart: {
    autoGeneratedBy: String, // AI, system rule, etc.
    similarNotifications: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Notification' }],
    consolidatedWith: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Notification' }],
    templateUsed: String,
    personalization: {
      userName: String,
      museumName: String,
      customFields: mongoose.Schema.Types.Mixed
    },
    aiSuggestions: [{
      suggestion: String,
      confidence: Number,
      reasoning: String
    }]
  },

  // Context and metadata
  context: {
    source: { type: String, required: true }, // system, user, api, cron_job, etc.
    sourceId: mongoose.Schema.Types.ObjectId,
    relatedEntity: {
      type: String,
      enum: ['artifact', 'museum', 'user', 'rental', 'event', 'tour', 'system']
    },
    relatedEntityId: mongoose.Schema.Types.ObjectId,
    metadata: mongoose.Schema.Types.Mixed,
    tags: [String],
    location: {
      country: String,
      region: String,
      city: String,
      coordinates: {
        type: { type: String, enum: ['Point'], default: 'Point' },
        coordinates: [Number] // [longitude, latitude]
      }
    }
  },

  // Status tracking
  status: {
    type: String,
    enum: ['draft', 'scheduled', 'sent', 'delivered', 'read', 'acted_upon', 'dismissed', 'expired', 'failed'],
    default: 'draft'
  },
  
  // Analytics and engagement
  analytics: {
    totalRecipients: { type: Number, default: 0 },
    delivered: { type: Number, default: 0 },
    opened: { type: Number, default: 0 },
    clicked: { type: Number, default: 0 },
    dismissed: { type: Number, default: 0 },
    actedUpon: { type: Number, default: 0 },
    failed: { type: Number, default: 0 },
    avgResponseTime: Number, // in minutes
    engagementScore: { type: Number, default: 0 },
    clickThroughRate: { type: Number, default: 0 },
    openRate: { type: Number, default: 0 }
  },

  // Expiration and lifecycle
  expiresAt: Date,
  archivedAt: Date,
  deletedAt: Date,
  
  // System fields
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  isActive: { type: Boolean, default: true },
  isDismissible: { type: Boolean, default: true },
  isArchived: { type: Boolean, default: false }

}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Indexes for performance
notificationSchema.index({ 'recipients.user': 1, status: 1, createdAt: -1 });
notificationSchema.index({ type: 1, category: 1, priority: 1 });
notificationSchema.index({ 'delivery.scheduled': 1, status: 1 });
notificationSchema.index({ expiresAt: 1 });
notificationSchema.index({ 'context.relatedEntity': 1, 'context.relatedEntityId': 1 });
notificationSchema.index({ createdAt: -1, priority: 1 });
notificationSchema.index({ 'analytics.engagementScore': -1 });

// Geo index for location-based notifications
notificationSchema.index({ 'context.location.coordinates': '2dsphere' });

// Text search index
notificationSchema.index({
  title: 'text',
  message: 'text',
  'context.tags': 'text'
});

// Virtual fields
notificationSchema.virtual('isExpired').get(function() {
  return this.expiresAt && new Date() > this.expiresAt;
});

notificationSchema.virtual('isUrgent').get(function() {
  return ['critical', 'urgent'].includes(this.priority);
});

notificationSchema.virtual('readPercentage').get(function() {
  return this.analytics.totalRecipients > 0 
    ? (this.analytics.opened / this.analytics.totalRecipients) * 100 
    : 0;
});

// Static methods

// Get notifications for a specific user
notificationSchema.statics.getForUser = function(userId, options = {}) {
  const query = {
    'recipients.user': userId,
    isActive: true,
    $or: [
      { expiresAt: { $exists: false } },
      { expiresAt: { $gt: new Date() } }
    ]
  };

  if (options.unreadOnly) {
    query['recipients.readAt'] = { $exists: false };
  }
  
  if (options.type) query.type = options.type;
  if (options.category) query.category = options.category;
  if (options.priority) query.priority = options.priority;

  return this.find(query)
    .sort({ 
      priority: options.priority === 'urgent' || options.priority === 'critical' ? -1 : 1,
      createdAt: -1 
    })
    .limit(options.limit || 50)
    .populate('createdBy', 'name email')
    .populate('context.relatedEntityId');
};

// Get pending notifications to send
notificationSchema.statics.getPendingDelivery = function() {
  const now = new Date();
  return this.find({
    status: { $in: ['draft', 'scheduled'] },
    isActive: true,
    $or: [
      { 'delivery.immediate': true, status: 'draft' },
      { 'delivery.scheduled': { $lte: now }, status: 'scheduled' }
    ],
    $or: [
      { expiresAt: { $exists: false } },
      { expiresAt: { $gt: now } }
    ]
  });
};

// Smart notification grouping
notificationSchema.statics.getSimilarNotifications = function(notification, timeWindow = 24) {
  const startTime = new Date(Date.now() - timeWindow * 60 * 60 * 1000);
  
  return this.find({
    _id: { $ne: notification._id },
    type: notification.type,
    category: notification.category,
    'context.relatedEntity': notification.context.relatedEntity,
    createdAt: { $gte: startTime },
    status: { $ne: 'consolidated' }
  });
};

// Analytics queries
notificationSchema.statics.getAnalytics = function(filters = {}) {
  const matchStage = { isActive: true };
  
  if (filters.startDate && filters.endDate) {
    matchStage.createdAt = {
      $gte: new Date(filters.startDate),
      $lte: new Date(filters.endDate)
    };
  }
  
  if (filters.type) matchStage.type = filters.type;
  if (filters.category) matchStage.category = filters.category;

  return this.aggregate([
    { $match: matchStage },
    {
      $group: {
        _id: {
          type: '$type',
          category: '$category',
          priority: '$priority'
        },
        count: { $sum: 1 },
        avgEngagement: { $avg: '$analytics.engagementScore' },
        totalRecipients: { $sum: '$analytics.totalRecipients' },
        totalOpened: { $sum: '$analytics.opened' },
        totalClicked: { $sum: '$analytics.clicked' },
        avgResponseTime: { $avg: '$analytics.avgResponseTime' }
      }
    },
    {
      $project: {
        type: '$_id.type',
        category: '$_id.category',
        priority: '$_id.priority',
        count: 1,
        avgEngagement: 1,
        openRate: {
          $cond: {
            if: { $gt: ['$totalRecipients', 0] },
            then: { $multiply: [{ $divide: ['$totalOpened', '$totalRecipients'] }, 100] },
            else: 0
          }
        },
        clickThroughRate: {
          $cond: {
            if: { $gt: ['$totalOpened', 0] },
            then: { $multiply: [{ $divide: ['$totalClicked', '$totalOpened'] }, 100] },
            else: 0
          }
        },
        avgResponseTime: 1
      }
    },
    { $sort: { count: -1 } }
  ]);
};

// Instance methods

// Mark as read for a specific user
notificationSchema.methods.markAsRead = function(userId) {
  const recipient = this.recipients.find(r => r.user.toString() === userId.toString());
  if (recipient && !recipient.readAt) {
    recipient.readAt = new Date();
    this.analytics.opened += 1;
    this.updateEngagementMetrics();
    return this.save();
  }
  return Promise.resolve(this);
};

// Mark as acted upon
notificationSchema.methods.markAsActedUpon = function(userId, response = null) {
  const recipient = this.recipients.find(r => r.user.toString() === userId.toString());
  if (recipient) {
    recipient.actionTaken = new Date();
    if (response) recipient.response = response;
    this.analytics.actedUpon += 1;
    this.updateEngagementMetrics();
    return this.save();
  }
  return Promise.resolve(this);
};

// Dismiss notification for a user
notificationSchema.methods.dismiss = function(userId) {
  const recipient = this.recipients.find(r => r.user.toString() === userId.toString());
  if (recipient && this.isDismissible && !recipient.dismissedAt) {
    recipient.dismissedAt = new Date();
    this.analytics.dismissed += 1;
    this.updateEngagementMetrics();
    return this.save();
  }
  return Promise.resolve(this);
};

// Update engagement metrics
notificationSchema.methods.updateEngagementMetrics = function() {
  const total = this.analytics.totalRecipients;
  
  if (total > 0) {
    this.analytics.openRate = (this.analytics.opened / total) * 100;
    this.analytics.clickThroughRate = this.analytics.opened > 0 
      ? (this.analytics.clicked / this.analytics.opened) * 100 
      : 0;
    
    // Calculate engagement score (weighted)
    this.analytics.engagementScore = 
      (this.analytics.opened * 1) +
      (this.analytics.clicked * 3) +
      (this.analytics.actedUpon * 5) -
      (this.analytics.dismissed * 1);
  }
};

// Send notification to recipients
notificationSchema.methods.send = async function() {
  if (this.status !== 'draft' && this.status !== 'scheduled') {
    throw new Error('Notification is not in sendable state');
  }

  try {
    this.status = 'sent';
    this.analytics.totalRecipients = this.recipients.length;
    this.delivery.deliveryCount += 1;
    
    // Here you would integrate with actual delivery services
    // For now, we'll just mark as delivered
    this.status = 'delivered';
    this.analytics.delivered = this.recipients.length;
    
    return this.save();
  } catch (error) {
    this.status = 'failed';
    this.analytics.failed = this.recipients.length;
    return this.save();
  }
};

// Auto-expire notifications
notificationSchema.methods.checkExpiration = function() {
  if (this.expiresAt && new Date() > this.expiresAt) {
    this.status = 'expired';
    return this.save();
  }
  return Promise.resolve(this);
};

// Pre-save middleware
notificationSchema.pre('save', function(next) {
  // Set default expiration if not set
  if (!this.expiresAt) {
    const expirationDays = {
      'low': 30,
      'medium': 14,
      'high': 7,
      'critical': 3,
      'urgent': 1
    };
    const days = expirationDays[this.priority] || 7;
    this.expiresAt = new Date(Date.now() + days * 24 * 60 * 60 * 1000);
  }
  
  // Update analytics
  if (this.isModified('analytics')) {
    this.updateEngagementMetrics();
  }
  
  next();
});

// Create index for TTL (Time To Live) - automatically delete expired notifications
notificationSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 0 });

module.exports = mongoose.model('Notification', notificationSchema);
